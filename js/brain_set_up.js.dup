//
// _brain_set_up will hold the three.js setup functionality
//

function _brain_set_up() {

     /////////////////////////////////////////
     // private
     /////////////////////////////////////////
     var parent = new super_brain();  
      
     var closed_object = this;   // holds the closure object

     var navigation_style = document.getElementById('main_navigation').currentStyle || window.getComputedStyle(document.getElementById('main_navigation'));

   var local_settings = {   
      
      viewportRatio : window.innerWidth / window.innerHeight,                                              
      // more will be dynamically populated for use in the current object scope 
      vector_direction : {x:-45, y: 270, z: 0 },
      vector_direction_near : {x:-45, y: 300, z: 0 },
      cameraDistance : {  x : 190, y : 350, z : 700},
      cameraNearDistance : {  x : 70, y : 350, z : 60, rotation: -135 },
      thinking : true, 
      rotate : false,
      navigation : document.getElementById('main_navigation'),       
      navigation_height_total : Number(navigation_style.marginTop.split('px')[0]),
      share_icon : document.getElementById('share'),
      logo_icon : document.getElementById('logo'),
      // menu_ position array starts with 0 because this is the initial starting position nd the shift function
      // will remove this first always leaving at least 1 index left in the array
      menu_position : [0],

      // this portion has to do with the loading state
      site_load_total : 1675836,
      loading_status : document.getElementById('load_status'),
      loading_progress : document.getElementById('loading_progress'),
      

   }


    // create the camera distance
    var distance = { 
           x: local_settings.cameraDistance.x - local_settings.cameraNearDistance.x,
           y: local_settings.cameraDistance.y - local_settings.cameraNearDistance.y, 
           z: local_settings.cameraDistance.z - local_settings.cameraNearDistance.z
    };

     // create the look at vector for rotating the camera
     var look_at_vector_distance = {
           x: local_settings.vector_direction.x - local_settings.vector_direction_near.x,
           y: local_settings.vector_direction.y - local_settings.vector_direction_near.y,
           z: local_settings.vector_direction.z - local_settings.vector_direction_near.z,
      }

   //helper function
   function progressBar( xhr ) {
       // to figure out how to find total when file is gzipped xhr out the .total attribute and 
       // the last number from the .loaded will be the total
       var loaded = (xhr.loaded / local_settings.site_load_total) * 100;
       local_settings.loading_status.style.width = loaded + '%';
       
   }   
   
   /////////////////////////////////////////
   // public
   /////////////////////////////////////////
  
   //name : init 
   //params: settings is a json object to set variables in the init_function
   //functions : sets up the initial variables when necessary
   // returns: nothing;
   this.init = function(settings = NULL) {
      if(typeof settings['scene'] != 'undefined') {
          parent.set_setting('scene', settings['scene']);
      }

      if(typeof settings['camera'] != 'undefined') {
          parent.set_setting('camera', settings['camera']);
      }

      if(typeof settings['renderer'] != 'undefined') {
          parent.set_setting('renderer', settings['renderer']);          
          parent.get_setting('renderer').setSize(window.innerWidth, window.innerHeight);
          document.body.appendChild(parent.get_setting('renderer').domElement);
      }        
   }

   // name : add
   // params: name holds the name of the object
   // params: value holds the value and type of object that is set
   // function : sets object for the scene
   // returns: nothing
   this.add = function(name,value) {                                                        
          parent.set_setting(name, value);              
   }

   // name : degtorad
   // params: degrees
   // functions translates degrees to radians
   // return : radians 
   this.degtorad = function (degrees) {
      return degrees * (Math.PI / 180);
   }
   
   // name : create_camera_distance_percentages
   // params : nav_position is the current position of the menu element
   // functions: uses camera distance and camera distance near to create and return a moving distance percentage
   // returns : a json object of moving camera distance
   this.create_camera_distance = function(nav_position) {
 
      var scrolling_percentage = (nav_position / local_settings.navigation_height_total );

      var moving_distance = {
         x : local_settings.cameraDistance.x - (distance.x * scrolling_percentage),
         y : local_settings.cameraDistance.y - (distance.y * scrolling_percentage),
         z : local_settings.cameraDistance.z - (distance.z * scrolling_percentage),
      };

      var moving_rotation = {
         x : local_settings.vector_direction.x - (look_at_vector_distance.x * scrolling_percentage),
         y : local_settings.vector_direction.y - (look_at_vector_distance.y * scrolling_percentage),
         z : local_settings.vector_direction.z - (look_at_vector_distance.z * scrolling_percentage),
      };

      var transform = {
          x : moving_distance.x * 2,
          y : moving_distance.y * 2,
          z : moving_distance.z * 2,
          r_x : moving_rotation.x,
          r_y : moving_rotation.y,
          r_z : moving_rotation.z,
          
          // m_r_y is model rotation on the y axis
          m_r_y : local_settings.cameraNearDistance.rotation * scrolling_percentage,
     }
 
      return transform;
   }
   
   // name: log_settings
   // params: name  defaults to null;
   // functions: if name is null calls parent to get all settings else returns the named value;
   // returns all the parents settings 
   this.get_setting = function(name = null) {
      return ( name == null ) ?  parent.get_all_settings() : parent.get_all_settings()[name];
   }  
   
   // name : add_to_scene
   // params: name is the name of the value of the three setting
   // functions: adds the named setting to the scene
   // returns: nothing
   this.add_to_scene = function(name) {

      this.get_setting('scene').add( this.get_setting(name) );
   }
   
   // name      : vertex_buffer_set_up
   // params    : none 
   // functions : creates the buffer to adjust in the vshader 
   // returns   : nothing
   this.vertex_buffer_set_up = function() {   
      
      this.add('manager', new THREE.LoadingManager());
      
      // add a json loading manager to animate
      this.add('loader', new THREE.FBXLoader(
           closed_object.get_setting('manager') 
      ) );

      // this function will get called every progress iteration
      this.get_setting('manager').onLoad = function( url, itemsLoaded, itemsTotal) {

          local_settings.loading_progress.style.display = "none";       
          closed_object.get_setting('current_action').reset();
      }   
     
     
         this.get_setting('loader').load('sites/all/themes/brain/models/sitespace2.fbx', function(model) {

            /// this is the animated skinnedmesh
            model.children[1].material = new THREE.MeshLambertMaterial({ color: 0xdddddd });
            model.children[1].material.skinning = true;


            // this is the ground
            model.children[0].material = new THREE.MeshLambertMaterial({ color: 0x5555fe });
            model.children[0].receiveShadow = true;
            
            closed_object.add('mixer', new THREE.AnimationMixer( model) );


            closed_object.add('thinking', closed_object.get_setting("mixer").clipAction(model.animations[4]) );      
            closed_object.add('dancing', closed_object.get_setting("mixer").clipAction(model.animations[6]) );        
        
            closed_object.add('current_action', closed_object.get_setting('dancing') );

            closed_object.get_setting('scene').add(model);
            
            closed_object.get_setting('current_action').play(); 
	
      }, progressBar );
     
   }
   
   
   // name : select_action
   // params: direction is a string either. up or down
   // functions : looks at the current state of the content and
   //             changes the action to the thinking if moving up it goes back o walking
   // returns : nothing
   this.select_action = function(direction) {

          if(direction == 'down') {
             
               closed_object.get_setting('current_action').crossFadeTo(
                   closed_object.get_setting('dancing'), 
                   1
                );

                closed_object.add('current_action', closed_object.get_setting('dancing'));
          }
          else {

               closed_object.get_setting('current_action').crossFadeTo(
               closed_object.get_setting('thinking'), 
               1
               );

               closed_object.add('current_action', closed_object.get_setting('thinking'));

          }

          closed_object.get_setting('current_action').reset();

          closed_object.get_setting('current_action').play();


   }
 

   // name : create_scene
   // params: none;
   // function : creates all the loaded objects and geometries not already in the scene
   // returns : nothing
   this.create_scene = function() {      
      
      this.add('ambient_light', new THREE.AmbientLight( 0xffffff ) );
             
      this.add('visible_mesh_geometry', new THREE.BufferGeometry());
      

      this.add('spot_light_red', new THREE.SpotLight( 0xffffff, .15 ) );
      this.get_setting('spot_light_red').position.y = 1000;
      this.get_setting('spot_light_red').position.z = 1000;
      
      this.get_setting('spot_light_red').castShadow = true;
                                     
      this.add_to_scene('spot_light_red');

      this.add_to_scene('ambient_light');

      this.add('clock', new THREE.Clock());
      
      this.get_setting('clock').start();

      // set the camera distance... originally I  was doing this based on user agent differences
      // variable holds DRY principles

      this.get_setting('camera').position.x = local_settings.cameraDistance.x;
      this.get_setting('camera').position.y = local_settings.cameraDistance.y;
      this.get_setting('camera').position.z = local_settings.cameraDistance.z;

      closed_object.get_setting('camera').lookAt(new THREE.Vector3(
                  local_settings.vector_direction.x,
                  local_settings.vector_direction.y,
                  local_settings.vector_direction.z
      ));      

      this.vertex_buffer_set_up();
   }

   // name     : rotate_model 
   // params   : direction is a string holding up or down 
   // function : rotates the model front or back
   // returns  : nothing
   this.rotate_model = function(direction) {
   
       var position = closed_object.create_camera_distance(local_settings.menu_position[0]);
       if(local_settings.thinking) {

          // on the first scroll we change the current action to thinking
          // after the action is switched it changes thinking to false and doesn't call it again
          // we set a timeout so that after 500 ms it changes a rotate to true setting and then if the local
          // settings rotate is true than we start rotating the model
          closed_object.select_action('up');
/*
          window.setTimeout(function() { 
             local_settings.rotate = true;
          }, 500);
*/
          local_settings.thinking = false;
       }

       
      if(local_settings.rotate) {
         if(direction == 'up' && local_settings.menu_position[0] > 0) {
              if (closed_object.get_setting('camera').position.z >= local_settings.cameraNearDistance.z ) {
//                  closed_object.get_setting('scene').children[2].children[2].rotation.z = closed_object.degtorad(position.m_r_y);
                  closed_object.get_setting('scene').children[2].updateMatrixWorld();
                  closed_object.get_setting('camera').position.x = position.x; 
                  closed_object.get_setting('camera').position.z = position.z; 
              }
          }
          else {
              if (closed_object.get_setting('camera').position.z <= local_settings.cameraDistance.z )  {
//                  closed_object.get_setting('scene').children[2].rotation.y += 0.06;
//                  closed_object.get_setting('scene').children[2].updateMatrixWorld();
                  closed_object.get_setting('camera').position.x = position.x; 
                  closed_object.get_setting('camera').position.z = position.z; 

              }         
                  if(local_settings.menu_position[0] <= 250) { 
                       closed_object.select_action('down');
                       local_settings.thinking = true;
                  }
 
          }
       }
       
   }
   
 
   // name     : render
   // params   : none
   // function : defines the render for the model
   // returns  : nothing
   this.render = function() {

       // wait for the animation mixer to catch up   
       if(typeof closed_object.get_setting('mixer') != 'undefined') {

           /// the docs say to pass into the mixer the delta. [new time - old time] and scale that by the mixers time scale
           // closed_object.get_setting('mixer').timeScale * closed_object.get_setting('clock').getDelta()
           closed_object.get_setting('mixer').update( closed_object.get_setting('clock').getDelta() );
       } 

       closed_object.get_setting('renderer').render(
           closed_object.get_setting('scene'),
           closed_object.get_setting('camera'),
       );
       

   }
   
   // name    : change_icon_color 
   // params  : none;
   // functions : checks menu position and if it is higher than the element add the blue class to the the element
   // returns: nothin
   this.change_icon_color = function() {
        if( local_settings.menu_position[0] >= window.innerHeight) {
           local_settings.share_icon.className = 'blue';          
        }
        else {
           local_settings.share_icon.className = '';
        }
        
        if( local_settings.menu_position[0] >= window.innerHeight * 1.5  ) {
           local_settings.logo_icon.className = 'blue';
        }
        else {
           local_settings.logo_icon.className = '';
        }
   }
    

   // name    : find_menu_position
   // params  : event is the event attributes;
   // functions : checks position of menu screen and changes icon color call this first to return the direction 
   //              of the rotation that way we do not call an unnecessary function and we don't take up unnecessary memory
   //              by allocating a variable for direction
   // returns :    scrolling direction
    
   this.find_menu_position = function(event) {

      local_settings.menu_position.push( window.pageYOffset || local_settings.navigation.scrollTop ); 
     var scrolling_direction;
       if(local_settings.menu_position.shift() <= local_settings.menu_position[0]) {
        scrolling_direction = 'up';
      }
      else {
         scrolling_direction = 'down';
      }
 
      return scrolling_direction;
   }
    
   // name : animate
   // params: none;
   // function: calls the looping animation sequence where rendering takes place
   // returns nothing 
   this.animate = function() {

       requestAnimationFrame(function() {
          closed_object.animate();               // calls a frame reliable function
       });
       
       closed_object.render();
    }   

   // name   : event_reciever
   // params : settings  is a json object with its settings that modify the current scenario
   // functions : takes in settings to adjust the current local settings
   // returns : nothing
   this.event_reciever = function(classification, settings) {
         
      if(classification == 'mouse_position') {
      
         var vector = new THREE.Vector3();

         vector.set(
           ( settings.x / window.innerWidth ) * 2 - 1,
         - ( settings.y / window.innerHeight ) * 2 + 1,
           0.5 );

         vector.unproject( closed_object.get_setting("camera") );

         var dir = vector.sub( closed_object.get_setting("camera").position ).normalize();

         var distance = -  closed_object.get_setting("camera").position.z / dir.z;

         var pos =  closed_object.get_setting("camera").position.clone().add( dir.multiplyScalar( distance ) );
      }
      else if(classification == 'bring content in focus') {
        var direction = closed_object.find_menu_position();
        closed_object.change_icon_color();
        closed_object.rotate_model(direction);
    
      }
    

   }      
}